{{- if eq .chezmoi.os "linux" -}}
#!/bin/bash
# run_once_after_98-merge-ssh-keys.sh.tmpl
# Smart merge for authorized_keys and SSH config to preserve existing entries
# Works for ANY role - file-based detection instead of role-based

echo "--- Smart Merge SSH Configuration ---"

# Backup Retention: Keep only 3 most recent backups
BACKUP_COUNT=$(ls -1d "$HOME"/.ssh.backup.* 2>/dev/null | wc -l)
if [ "$BACKUP_COUNT" -gt 3 ]; then
    echo "Cleaning old SSH backups (keeping 3 most recent)..."
    ls -td "$HOME"/.ssh.backup.* 2>/dev/null | tail -n +4 | xargs rm -rf
    REMOVED=$((BACKUP_COUNT - 3))
    echo "  -> Removed $REMOVED old backup(s)"
fi

# Helper function: Find most recent backup
get_latest_ssh_backup() {
    ls -td "$HOME"/.ssh.backup.* 2>/dev/null | head -n1
}

# ===== 1. MERGE AUTHORIZED_KEYS =====
AUTHORIZED_KEYS="$HOME/.ssh/authorized_keys"
if [ -f "$AUTHORIZED_KEYS" ]; then
    echo "Found authorized_keys. Checking for backup to merge..."

    LATEST_BACKUP=$(get_latest_ssh_backup)

    if [ -n "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP/authorized_keys" ]; then
        # Validate backup file is readable and not empty
        if [ ! -r "$LATEST_BACKUP/authorized_keys" ]; then
            echo "  -> Warning: Backup file is not readable. Skipping merge."
        elif [ ! -s "$LATEST_BACKUP/authorized_keys" ]; then
            echo "  -> Backup file is empty. Skipping merge."
        else
            echo "Merging authorized_keys with backup from: $(basename "$LATEST_BACKUP")"

            # Create temp file with new keys (generated by chezmoi)
            cp "$AUTHORIZED_KEYS" "$AUTHORIZED_KEYS.new"

        # Track preserved keys
        PRESERVED_COUNT=0
        HEADER_ADDED=false

        # Append old keys that don't exist in new file
        while IFS= read -r line; do
            # Skip comments and empty lines
            if [[ "$line" =~ ^#.*$ ]] || [[ -z "$line" ]]; then
                continue
            fi

            # Extract key fingerprint (type + key, ignore comment)
            key_part=$(echo "$line" | awk '{print $1, $2}')

            # Check if key already exists in new file
            if ! grep -qF "$key_part" "$AUTHORIZED_KEYS.new"; then
                # Add header only once
                if [ "$HEADER_ADDED" = false ]; then
                    echo "" >> "$AUTHORIZED_KEYS.new"
                    echo "# ===== Preserved from previous configuration =====" >> "$AUTHORIZED_KEYS.new"
                    HEADER_ADDED=true
                fi
                echo "$line" >> "$AUTHORIZED_KEYS.new"
                PRESERVED_COUNT=$((PRESERVED_COUNT + 1))
            fi
        done < "$LATEST_BACKUP/authorized_keys"

            # Replace with merged file
            mv "$AUTHORIZED_KEYS.new" "$AUTHORIZED_KEYS"
            chmod 600 "$AUTHORIZED_KEYS"
            echo "  -> Merged successfully! Preserved $PRESERVED_COUNT old key(s)."
        fi
    else
        echo "  -> No backup found. Keeping current authorized_keys as-is."
    fi
else
    echo "No authorized_keys file found (expected for client-only roles)."
fi

# ===== 2. MERGE SSH CONFIG =====
SSH_CONFIG="$HOME/.ssh/config"
SSH_CONFIG_LOCAL="$HOME/.ssh/config.local"

if [ -f "$SSH_CONFIG" ]; then
    echo "Found SSH config. Checking for custom entries to preserve..."

    LATEST_BACKUP=$(get_latest_ssh_backup)

    # Ensure config.local Include directive exists
    if ! grep -q "Include.*config.local" "$SSH_CONFIG"; then
        echo "  -> Adding config.local include directive..."
        echo "" >> "$SSH_CONFIG"
        echo "# Local overrides (not managed by dotfiles)" >> "$SSH_CONFIG"
        echo "Include ~/.ssh/config.local" >> "$SSH_CONFIG"
    fi

    # If there's a backup AND it has custom entries, help user merge
    if [ -n "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP/config" ]; then
        # Extract custom Host entries (not managed by dotfiles)
        CUSTOM_HOSTS=$(mktemp)
        IN_CUSTOM_HOST=false
        FOUND_CUSTOM=false

        while IFS= read -r line; do
            # Skip dotfiles-managed sections
            if [[ "$line" =~ "# .ssh/config - Managed by Chezmoi" ]] || \
               [[ "$line" =~ "# Role-Based Keys" ]] || \
               [[ "$line" =~ "# Common Configuration" ]]; then
                IN_CUSTOM_HOST=false
                continue
            fi

            # Detect Host blocks
            if [[ "$line" =~ ^Host[[:space:]]+(.+)$ ]]; then
                HOST_NAME="${BASH_REMATCH[1]}"
                # Check if this is NOT a dotfiles-managed host
                if [[ "$HOST_NAME" != "*" ]] && \
                   [[ "$HOST_NAME" != "github.com" ]] && \
                   ! grep -q "^Host[[:space:]]\+$HOST_NAME" "$SSH_CONFIG" 2>/dev/null; then
                    IN_CUSTOM_HOST=true
                    FOUND_CUSTOM=true
                    echo "$line" >> "$CUSTOM_HOSTS"
                else
                    IN_CUSTOM_HOST=false
                fi
            elif [ "$IN_CUSTOM_HOST" = true ]; then
                echo "$line" >> "$CUSTOM_HOSTS"
                # Empty line marks end of Host block
                if [[ -z "$line" ]]; then
                    IN_CUSTOM_HOST=false
                fi
            fi
        done < "$LATEST_BACKUP/config"

        # If custom hosts found, append to config.local
        if [ "$FOUND_CUSTOM" = true ] && [ -s "$CUSTOM_HOSTS" ]; then
            touch "$SSH_CONFIG_LOCAL"

            CUSTOM_COUNT=$(grep -c "^Host " "$CUSTOM_HOSTS" || echo "0")
            echo "  -> Found $CUSTOM_COUNT custom Host entry/entries in backup."
            echo "  -> Merging into config.local..."

            echo "" >> "$SSH_CONFIG_LOCAL"
            echo "# ===== Migrated from previous config =====" >> "$SSH_CONFIG_LOCAL"
            cat "$CUSTOM_HOSTS" >> "$SSH_CONFIG_LOCAL"

            echo "  -> Custom entries preserved in config.local"
        else
            echo "  -> No custom Host entries found in backup."
        fi

        rm -f "$CUSTOM_HOSTS"
    fi
else
    echo "No SSH config file found (will be created by chezmoi if needed)."
fi

echo "SSH configuration merge complete."
{{ end }}
